package utils

import (
	"bytes"
	"errors"
	"github.com/saranblock3/cryptopals/resources"
	"math"
)

// Performs bitwise xor on two byte slices and returns the result (with an error)
func XorByteSlice(byteSlice0, byteSlice1 []byte) ([]byte, error) {
	// if slices not equal length return error
	if len(byteSlice0) != len(byteSlice1) {
		return nil, errors.New("Length of Slices not equal!")
	}
	resSlice := make([]byte, len(byteSlice0), len(byteSlice0))
	// xor corresponding byte from each slice
	for idx := range byteSlice0 {
		resSlice[idx] = byteSlice0[idx] ^ byteSlice1[idx]
	}
	return resSlice, nil
}

// Decrypts cipher text that has been XORed against a single byte
// and return the key, the plain text and the mse between the english
// letter frequency and the plain text letter frequency
func DecryptSingleByteXor(cipherText []byte) (byte, string, float64) {
	// byte frequency for the each 'plain text' after each decryption
	bytesFreqMap := make(map[byte]float64)
	// initialize final variables
	var mse float64 = math.Inf(1)
	var key byte
	var plainText string
	// loop through range of possible keys
	for currentKey := 0; currentKey < 256; currentKey++ {
		// the so called plain text for the current key
		testPlainText := bytes.ToUpper(XorBytesByByte(cipherText, byte(currentKey)))
		// populate the byte frequency map with the current plain text
		FillBytesFreqMap(&bytesFreqMap, testPlainText)
		// get the mean square error between the current byte frequency
		// map and the english letter frequency map
		currentMse := MeanSquareError(resources.EngCharFreqMap, bytesFreqMap)
		// find the lowest mse value and update the other variables
		if currentMse < mse {
			mse = currentMse
			key = byte(currentKey)
			plainText = string(testPlainText)
		}
	}
	return key, plainText, mse
}

// Returns the result of byte slice XORed by a single byte
func XorBytesByByte(cipherText []byte, key byte) []byte {
	resByteSlice := make([]byte, len(cipherText), len(cipherText))
	for idx, currentByte := range cipherText {
		resByteSlice[idx] = currentByte ^ key
	}
	return resByteSlice
}
